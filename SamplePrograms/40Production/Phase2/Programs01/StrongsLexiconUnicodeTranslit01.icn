#The field separator character is "~".
#The first field is the Strongs number.
#The second field is the Hebrew word. This must be transliterated.
#Everything else up to the line-feed can be treated as the definition. Hebrew may be transliterated.

global translit, startNote, endNote

procedure main()
# This program reads the Brown-Driver-Brigs Hebrew Lexicon and transliterates the 
# Hebrew lemmas for later processing.

  # Constants
  r2l := "\xE2\x80\xAB"; l2r := "\xE2\x80\xAA"
  endPara := "\x20\xD7\xA4\xE2\x80\xAC"; endVerse := "\x20\xE2\x80\xAC"
  endSec := "\x20\xD7\xA1\xE2\x80\xAC"
  endParaNoSpace := "\xD7\xA4\xE2\x80\xAC"; endVerseNoSpace := "\xE2\x80\xAC"
  endSecNoSpace := "\xD7\xA1\xE2\x80\xAC"
  nunHafukha := "\xD7\x86" # Nun Hafukha (Backwards Nun)
  startNote := "\xE2\x80\xAA\x5B"; endNote := "\x5D\xE2\x80\xAC"
  translit := table("")
  translit["\xC2\xB4"] := "A" # Aleph With Diaresis
  translit["\xC2\xA0"] := ""  # Non Break Space
  translit["\xC5\xA1"] := ""  # 
  translit["\xD6\xB0"] := ""  # Sheva (e in met or silent)
  translit["\xD6\xB1"] := ""  # Hataf Segol (e in set)
  translit["\xD6\xB2"] := ""  # Hataf Patah (a in bad)
  translit["\xD6\xB3"] := ""  # Hataf Kamats (o in top)
  translit["\xD6\xB4"] := ""  # Hirik (i in hit)
  translit["\xD6\xB5"] := ""  # Tsere (e in they)
  translit["\xD6\xB6"] := ""  # Segol (e in set)
  translit["\xD6\xB7"] := ""  # Patah (a in bad)
  translit["\xD6\xB8"] := ""  # Kamats (a in father)
  translit["\xD6\xB9"] := ""  # Holam (o in pole) (left Sin dot)
  translit["\xD6\xBA"] := ""  # Holam Haser For Vav (o in pole)
  translit["\xD6\xBB"] := ""  # Kubuts (u in pull)
  translit["\xD6\xBC"] := ""  # Dagesh/Mapiq (dot inside letter) (hard vs fricative)
  translit["\xD6\xBD"] := ""  # Meteg (Marks secondary stress and vowel length)
  translit["\xD6\xBE"] := " " # Makef (Hyphen/Minus)
  translit["\xD6\xBF"] := " " # Rafeh (dash)
  translit["\xD7\x81"] := ""  # Right Shin Dot
  translit["\xD7\x83"] := ":" # Sof Pasuq (colon) (Equivalent to a period)
  translit["\xD7\x86"] := ""  # Nun Hafukha (Backwards Nun) (Used like brackets, 9 occurances in the Tanach)
  translit["\xD7\x90"] := "A" # Aleph
  translit["\xD7\x91"] := "B" # Beth
  translit["\xD7\x92"] := "G" # Gimel
  translit["\xD7\x93"] := "D" # Daleth
  translit["\xD7\x94"] := "H" # He
  translit["\xD7\x95"] := "V" # Vav / Waw
  translit["\xD7\x96"] := "Z" # Zayin
  translit["\xD7\x97"] := "X" # Heth / Cheth
  translit["\xD7\x98"] := "+" # Teth
  translit["\xD7\x99"] := "Y" # Yod
  translit["\xD7\x9A"] := "K" # Kaph Sofit (Final Kapf)
  translit["\xD7\x9B"] := "K" # Kaph
  translit["\xD7\x9C"] := "L" # Lamed
  translit["\xD7\x9D"] := "M" # Mem Sofit (Final Mem)
  translit["\xD7\x9E"] := "M" # Mem
  translit["\xD7\x9F"] := "N" # Nun Sofit (Final Nun)
  translit["\xD7\xA0"] := "N" # Nun
  translit["\xD7\xA1"] := "$" # Samek
  translit["\xD7\xA2"] := "@" # Ayin
  translit["\xD7\xA3"] := "P" # Pe Sofit (Final Pe)
  translit["\xD7\xA4"] := "P" # Pe
  translit["\xD7\xA5"] := "C" # Tsade Sofit (Final Tsade)
  translit["\xD7\xA6"] := "C" # Tsade
  translit["\xD7\xA7"] := "Q" # Qoph
  translit["\xD7\xA8"] := "R" # Resh
  translit["\xD7\xA9"] := "S" # Sin / Shin
  translit["\xD7\xAA"] := "T" # Taw
  translit["\xD7\xB0"] := ""  # Tsvey Vovn: Hebrew Ligature Yiddish Double Vav
  translit["\xD7\xB1"] := ""  # Vov Yud: Hebrew Ligature Yiddish Vav Yod
  translit["\xD7\xB2"] := ""  # Tsvey Yudn: Hebrew Ligature Yiddish Double Yod
  translit["\xD7\xB3"] := ""  # Geresh (Apostrophe)
  translit["\xD7\xB4"] := ""  # Gershayim (Quotation Mark)
  translit["\xEF\xAC\x9E"] := ""  # Judeo-Spanish Varika

    fileName := "StrongsHebrewData.txt"
    fileNameOut := fileName[1:-4] || ".out.txt"
    file01 := open(fileName,"r") | stop("Cannot open ",fileName)
    file02 := open(fileNameOut,"w") | stop("Cannot open ",fileNameOut)
    hebrewEncountered := 0; 
    while (lineIn := read(file01)) do {
      lineIn ? {
        strongsNumber := tab(upto('~')); move(1); hebrewWord := tab(upto('~')); move(1); definition := tab(0)
        transliteratedHebrewWord := transliterateWord(strongsNumber,hebrewWord)
        write(file02,right(strongsNumber,6),right(transliteratedHebrewWord,15)," : ")
        while (*definition > 0) do {
          definition ? { if (lineOut := tab(upto('~'))) then
                           move(1)
                         else
                           lineout := tab(0)
            definition := definition[&pos:0]
            transedLine := transliterate(strongsNumber,lineOut)
            write(file02,repl(" ",24),transedLine)
          }
        }
        write(file02," ")
      }

    }
end

procedure transliterateWord(strongsNumber,wordIn)
  transedWord := ""
  while (*wordIn > 0) do {
    wordIn ? { 
      if ((oldChar := move(2))) then {
        newChar := translit[oldChar]
        if (*newChar > 0) then {
          transedWord ||:= newChar
          wordIn := wordIn[&pos:0]
          #write("Middle of transliterateWord wordIn>",wordIn,"< Strongs# ",strongsNumber)
        } 
        else {
          #write("Middle of transliterateWord: Something is wrong!")
          #write("wordIn >",wordIn,"< Strongs# ",strongsNumber) 
          #newChar := "*"
          #transedWord ||:= newChar
          wordIn := wordIn[&pos:0]
        }
      } else {write("transliterateWord says, Help! Help! I'm very confused!")
              write("wordIn >",wordIn,"< Strongs# ",strongsNumber) 
              transedWord ||:= "************************" || wordIn
              write("transedWord >",transedWord,"<")
              wordIn := ""}      
    }
  }
  return transedWord
end

procedure transliterate(strongsNumber,lineIn)
  transedLine := ""
  #write("Top of transliterate lineIn>",lineIn,"<")
  while (*lineIn > 0) do {
    lineIn ? {
      if (tempStr := tab(upto('\xC2\xC5\xD6\xD7')) & (oldChar := move(2))) then {
        if (newChar := translit[oldChar]) then {
          transedLine ||:= tempStr || newChar
          lineIn := lineIn[&pos:0]
          #write("Middle of transliterate lineIn>",lineIn,"< Strongs# ",strongsNumber)
        } else write("Middle of transliterate: Something is wrong!")
      } 
      else {
        return lineIn
#              write("transliterate says, Help! Help! I'm very confused!")
#              write("lineIn >",lineIn,"<") 
#              transedLine ||:= "************************" || lineIn
#              write("transedLine >",transedLine,"< Strongs# ",strongsNumber)
#              lineIn := ""
      }
    }
  } 
  if (*transedLine = 0) then transedLine ||:= lineIn
  return transedLine
end
