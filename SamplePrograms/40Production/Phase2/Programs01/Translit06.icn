# This program uses the alphabet table to convert a Strong's Hebrew Lexicon
# to a common transliteration so it can be easily read. The Hebrew coding of the input file must be
# "Hebrew (Windows-1255) Encoded Text." You can create such a file easily with the Libre Office 
# "Save As" option.
# Note: When creating a conversion table, "Don't forget the five Hebrew final forms!" Also, any
#       unwanted characters (like vowells or punctuation) can be converted to the empty string.

# In this version of the program we will capture the Hebrew words, compute their numbers,
# and write this information to WorkingOut03.txt. It has become apparant that the
# text in WorkingOut02.txt is not going to be adequate. Therefore, a new version of 
# WorkingOut02.txt will be created using Unicode-UTF8. Then file 02 and 03 will be 
# joined to produce the final lexicon.

link factors
global alphaCset, alphabet, file02, file03, placeTable, numericTable
procedure main()
# Initializations
  file01 := open("WorkingOut01.txt","r") | stop("Unable to open WorkingOut01.txt.")
  file02 := open("WorkingOut02.txt","w") | stop("Unable to open WorkingOut02.txt.")
  file03 := open("WorkingOut03.txt","w") | stop("Unable to open WorkingOut03.txt.")

# Create the empty Alphabet Table. 
# This table is based on Windows Code Page 1255 - Hebrew.
  alphabet := table("")

# Initialize the Alphabet Table.
  alphabet["\xC0"] := "" # Begin Vowels
  alphabet["\xC1"] := "" # Sheva
  alphabet["\xC2"] := "" # Hataf Segol
  alphabet["\xC3"] := "" # Hataf Patah
  alphabet["\xC4"] := "" # Hataf Qamats
  alphabet["\xC5"] := "" # Hiriq
  alphabet["\xC6"] := "" # Tsere
  alphabet["\xC7"] := "" # Segol
  alphabet["\xC8"] := "" # Patah
  alphabet["\xC9"] := "" # Qamats
  alphabet["\xCA"] := "" # Holam
  alphabet["\xCB"] := "" # Qubuts
  alphabet["\xCC"] := "" # Dagesh or Mapiq
  alphabet["\xCD"] := "" # Meteg
  alphabet["\xCE"] := "" # Maqaf
  alphabet["\xCF"] := "" # Rafe
  alphabet["\xD0"] := "" # Paseq
  alphabet["\xD1"] := "" # Shin Dot
  alphabet["\xD2"] := "" # Sin Dot
  alphabet["\xD3"] := "" # Sof Pasuq (colon)
  alphabet["\xD4"] := "" # Yiddish Double Vav
  alphabet["\xD5"] := "" # Vav Yod
  alphabet["\xD6"] := "" # Double Yod
  alphabet["\xD7"] := "" # Geresh
  alphabet["\xD8"] := "" # Gershayim
  alphabet["\xE0"] := "A" # Begin Consonants: Aleph
  alphabet["\xE1"] := "B" # Beth
  alphabet["\xE2"] := "G" # Gimel
  alphabet["\xE3"] := "D" # Daleth
  alphabet["\xE4"] := "H" # He
  alphabet["\xE5"] := "V" # Vav
  alphabet["\xE6"] := "Z" # Zayin
  alphabet["\xE7"] := "X" # Heth
  alphabet["\xE8"] := "+" # Teth
  alphabet["\xE9"] := "Y" # Yod
  alphabet["\xEA"] := "K" # Final Kaf
  alphabet["\xEB"] := "K" # Kaf
  alphabet["\xEC"] := "L" # Lamed
  alphabet["\xED"] := "M" # Final Mem
  alphabet["\xEE"] := "M" # Mem
  alphabet["\xEF"] := "N" # Final Nun
  alphabet["\xF0"] := "N" # Nun
  alphabet["\xF1"] := "$" # Samekh
  alphabet["\xF2"] := "@" # Ayin
  alphabet["\xF3"] := "P" # Final Pe
  alphabet["\xF4"] := "P" # Pe
  alphabet["\xF5"] := "C" # Final Tsade
  alphabet["\xF6"] := "C" # Tsade
  alphabet["\xF7"] := "Q" # Qoph
  alphabet["\xF8"] := "R" # Resh
  alphabet["\xF9"] := "S" # Sin/Shin
  alphabet["\xFA"] := "T" # Tav
#  alphabet["\xFD"] := "" # Left to Right Mark
#  alphabet["\xFE"] := "" # Right to Left Mark

# Write the content of the alphabet table to the console.
#  every a := key(alphabet) do
#    write(file02,a,":",alphabet[a])

# Create a cset containing the letters in alphabet.
# The cset will be used to identify Hebrew words.
  alphaString := ""
  every a := key(alphabet) do
    alphaString ||:= a
  alphaCset := cset(alphaString)
#  write(file02,"alphabetCset ==",alphaString,"== Length = ",*alphaString)

# Create a table containing Place values for the Hebrew alphabet.
  placeTable := table(0)
  placeTable["A"] := 1
  placeTable["B"] := 2
  placeTable["G"] := 3
  placeTable["D"] := 4
  placeTable["H"] := 5
  placeTable["V"] := 6
  placeTable["Z"] := 7
  placeTable["X"] := 8
  placeTable["+"] := 9
  placeTable["Y"] := 10
  placeTable["K"] := 11
  placeTable["L"] := 12
  placeTable["M"] := 13
  placeTable["N"] := 14
  placeTable["$"] := 15
  placeTable["@"] := 16
  placeTable["P"] := 17
  placeTable["C"] := 18
  placeTable["Q"] := 19
  placeTable["R"] := 20
  placeTable["S"] := 21
  placeTable["T"] := 22

# Create a table containing Numeric values for the Hebrew alphabet.
  numericTable := table(0)
  numericTable["A"] := 1
  numericTable["B"] := 2 
  numericTable["G"] := 3
  numericTable["D"] := 4
  numericTable["H"] := 5
  numericTable["V"] := 6
  numericTable["Z"] := 7
  numericTable["X"] := 8
  numericTable["+"] := 9
  numericTable["Y"] := 10
  numericTable["K"] := 20
  numericTable["L"] := 30
  numericTable["M"] := 40
  numericTable["N"] := 50
  numericTable["$"] := 60
  numericTable["@"] := 70
  numericTable["P"] := 80
  numericTable["C"] := 90
  numericTable["Q"] := 100
  numericTable["R"] := 200
  numericTable["S"] := 300
  numericTable["T"] := 400

# Convert file01 in it's own code set (Windows-1255) to file02 in the common code set.
  while lineIn := read(file01) do {
    strongsNumber := lineIn[1:10]
    lineIn := lineIn[10:0]
    lineIn := translit(strongsNumber,lineIn)
    write(file02,strongsNumber,lineIn)
  }
end

procedure translit(strongsNumber,lineIn)
  lineOut := ""
  while *lineIn > 0 do { 
    partA := partB := partC := partD := ""
    lineIn ? {
      partA := tab(upto(alphaCset)) # Save leading non-Hebrew text.
      if (partB := tab(many(alphaCset))) then { # Save Hebrew word.
        partC := translitHebrew(strongsNumber,partB) # Transliterate the Hebrew Word.
        partD := tab(0) # Save the remainder -- the definition.
        #write("lineOut ==",lineOut)
        #write("partA ==",partA)
        #write("partC ==",partC)
        #write("partB ==",partB)
        lineOut ||:= (partA || partC || " " || partB) # Notice we saved the original Hebrew.
        lineIn := partD # Redo with shorter line.
      }
      else {
        lineOut ||:= lineIn
        return lineOut 
      }
    }
  }
end

procedure translitHebrew(strongsNumber,hebrewWord)
  transedWord := ""
  #write(file02,"hebrewText ==>",hebrewText,"<") #Diagnostic
  hebrewWord ? {
    while (nextChar := move(1)) do {
      transedChar := alphabet[nextChar]
      transedWord ||:= transedChar
      #write(file02,"nextChar ==>",nextChar,"< transedChar ==>",transedChar,"< transedHebrew ==>",transedHebrew,"<")
    }
    produceNumerics(strongsNumber,transedWord)
  }
return transedWord
end

procedure produceNumerics(strongsNumber,transedWord)
  placeValue := numericValue := 0
  transedWord ? {
    while (nextChar := move(1)) do {
      placeValue   +:= placeTable[nextChar]
      numericValue +:= numericTable[nextChar]
    }
  }
  placeValueFactors := formatFactors(placeValue)
  numericValueFactors := formatFactors(numericValue)
  horizPlace := horizTotals(placeValue)
  horizValue := horizTotals(numericValue)
  write(file03,strongsNumber,transedWord," ",placeValue,"*",placeValueFactors,"*(",horizPlace,")<>",numericValue,"*",numericValueFactors,"*(",horizValue,")")
  return [placeValue,placeValueFactors,horizPlace,numericValue,numericValueFactors,horizValue]
end

procedure horizTotals(numberIn)
# This procedure totals the digits of a number, and produces 
# its "Casting-Out-Nines" values.
  CO9s := ""; horizTotal := 0
  numberIn ? {
    while (nextChar := move(1)) do {
      horizTotal +:= nextChar      # Total the digits of numberIn.
    }
  }
  CO9s ||:= horizTotal || "|"  # Add the Horizontal Total to the return values.
  horizFactors := formatFactors(horizTotal)
  CO9s ||:= horizFactors || "|"  # Add the Horizontal Factors to the return values.
  CO9Total := horizTotal
    while *CO9Total > 1 do {
      total := 0
      CO9Total ? {
        while (nextChar := move(1)) do {
          total +:= nextChar
        }
      CO9Total := total
      }
    }
    CO9s ||:= CO9Total
  return CO9s
end

procedure formatFactors(numberIn)
  facs := factors(numberIn)
  facsOut := ""
  every i := 1 to *facs do {if i > 1 then spx := "x" else spx := ""
                                   facsOut ||:= spx || facs[i]}
  if *facsOut < 1 then facsOut := numberIn
return facsOut
end
