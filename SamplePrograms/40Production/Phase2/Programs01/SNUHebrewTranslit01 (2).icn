# This program reads a series of ISO-8859-8 (Hebrew) encoded HTML Tanach files and 
# transliterates them for later processing.

global translit, fileName

procedure main()

  # Constants
  space := "\x20"; comma := "\x2C"; period := "\x2E"
  colon := "\x3A"; semicolon := "\x3B"
  leftBrace := "\x7B"; rightBrace := "\x7D"

# Translation Table
  translit := table("")
  translit["\xE0"] := "A" # Aleph
  translit["\xE1"] := "B" # Beth
  translit["\xE2"] := "G" # Gimel
  translit["\xE3"] := "D" # Daleth
  translit["\xE4"] := "H" # He
  translit["\xE5"] := "V" # Vav or Waw
  translit["\xE6"] := "Z" # Zayin
  translit["\xE7"] := "X" # Heth or Cheth
  translit["\xE8"] := "+" # Teth
  translit["\xE9"] := "Y" # Yod
  translit["\xEA"] := "K" # Kaph Sofit (Final Kapf)
  translit["\xEB"] := "K" # Kaph
  translit["\xEC"] := "L" # Lamed
  translit["\xED"] := "M" # Mem Sofit (Final Mem)
  translit["\xEE"] := "M" # Mem
  translit["\xEF"] := "N" # Nun Sofit (Final Nun)
  translit["\xF0"] := "N" # Nun
  translit["\xF1"] := "$" # Samek
  translit["\xF2"] := "@" # Ayin
  translit["\xF3"] := "P" # Pe Sofit (Final Pe)
  translit["\xF4"] := "P" # Pe
  translit["\xF5"] := "C" # Tsade Sofit (Final Tsade)
  translit["\xF6"] := "C" # Tsade
  translit["\xF7"] := "Q" # Qoph
  translit["\xF8"] := "R" # Resh
  translit["\xF9"] := "S" # Sin / Shin
  translit["\xFA"] := "T" # Tav or Taw
  translit[","]    := ""  # Comma
  translit["."]    := ""  # Period
  translit[";"]    := ""  # Semicolon
  translit[":"]    := ""  # Colon
  translit[""]     := ""  #

  bookNames := table("")
  file00 := open("BookNames.txt","r") | stop("Can't open BookNames.txt.")
  while lineIn := read(file00) do { # Load all the book names into a table.
    bookNames[lineIn[1:3]] := lineIn[4:7]
  }
  close(file00)
  
  file00 := open("FileNames.txt","r") | stop("Cannot open FileNames.txt.")
  gTotalVerseCount   := 0 # Total over the entire Tanach.
  gTotalChapterCount := 0 # Total over the entire Tanach.
  file03 := open("Snu_Statistics.txt","w") | stop("Cannot open Snu_Statistics.txt.")
  write(file03,"Snunit Hebrew","\n")
  while (fileName := read(file00)) do { # Begin outer while
    fileNameIn  := fileName 
    book := bookNames[fileName[1:3]]
    fileNameOut := fileName[1:3] || "_" || book || ".txt"
    write("Input ==",fileNameIn," Output ==",fileNameOut)
    file01 := open(fileNameIn,"r") | stop("Cannot open ",fileNameIn)
    file02 := open(fileNameOut,"w") | stop("Cannot open ",fileNameOut)
    chapNum := 0
    verseCount := 0
    chapCount := 0
    hebrewEncountered := 0; 
    write("File ",fileNameIn," is open."," book == ",book)
    read()
    while (lineIn := trim(read(file01))) do { # Begin inner while
      if *lineIn < 1 then next # Skip blank lines.
      #write("MainLoop lineIn>",lineIn,"<") # Diagnostic
      if lineIn == unicodeCookie then next
      if find("[Commentary]",lineIn) then { # New Chapter
        chapNum   +:= 1 # Chapter number within book.
        chapCount +:= 1 # Chapter count within the Tanach.
        verse := 0 # Verse number within chapter.
        next # Get next lineIn.
      } 
      if lineIn[1:2] == period then next # Skip Verse Number
      if (lineIn[-5:0] == endPara)  then lineIn := lineIn[1:-5]
      if (lineIn[-5:0] == endSec)   then lineIn := lineIn[1:-5]
      if (lineIn[-2:0] == endVerse) then lineIn := lineIn[1:-2]
      lineIn ? { # Remove extraneous verse numbers (alternate versification)
        # The following two lines contain an old Snobol4 style pattern.
        if (tab(many(&digits)) & tab(match(":")) & tab(many(&digits)) & 
            tab(match(nonBreakSpace))) then {
            #write("Before lineIn >",lineIn) # Diagnostic
            lineIn := lineIn[&pos:0]
            #write("After1 lineIn >",lineIn) # Diagnostic
        }
      }
      #write("Before transliterate>",lineIn,"<") # Diagnostic
      lineIn := transliterate(lineIn)
      #write("After transliterate>",lineIn,"<") # Diagnostic
      verse +:= 1 # Verse number within a chapter.
      verseCount +:= 1 # Verse count within a book
      gTotalVerseCount +:= 1 # Verse count within the Tanach
      lineIn:= reformatLine(gTotalVerseCount,verseCount,book,chapNum,":",verse,lineIn)
      write(file02,trim(lineIn)) 
      #write(trim(lineIn)) # Diagnostic
    } # End inner while
    verseCount := "000" || verseCount; verseCount := verseCount[-4:0]
    chap  := "00" || chapNum; chap := chap[-3:0]
    if book == "Oba" then chp := " chapter." else chp := " chapters."
    write(file03,book," has ",verseCount," verses and ",chap,chp)
    gTotalChapterCount +:= chapNum
  } # End outer while
  write(file03,"This Tanach has ",gTotalVerseCount," verses and ",
                                 gTotalChapterCount," chapters.")
end

procedure reformatLine(gTotalVerseCount,verseCount,book,chap,colon,verse,lineIn)
  chap  := "00" || chap;  chap  :=  chap[-3:0] || colon
  verse := "00" || verse; verse := verse[-3:0] || " "
  verseCount := "0000" || verseCount; verseCount := verseCount[-5:0] || " "
  gTotalVerseCount := "0000" || gTotalVerseCount; gTotalVerseCount := gTotalVerseCount[-5:0] || " "
  return gTotalVerseCount || verseCount || book || " " || chap || verse || lineIn
end


procedure transliterate(lineIn)
  transedLine := ""; lineIn ||:= "\xC2\xA0" # Add a non-break-space to the end.
  #write("Top of transliterate lineIn>",lineIn,"<") # Diagnostic
  repeat { 
    lineIn ? { # Remove all *'s from the input line.
      if (pos := find("*")) then {
        lineIn := lineIn[1:pos] || lineIn[pos+1:0]
      }
      else break
    }
  }
  while (*lineIn > 0) do {
    lineIn ? {
      oldChar := newChar := "" # Initialize
      if (tempStr := tab(upto('\xC2\xD6\xD7'))) then {
        oldChar := move(2)
      } 
#      else {
#        oldChar := move(1)}
      if (newChar := translit[oldChar]) then {
        transedLine ||:= tempStr || newChar
        lineIn := lineIn[&pos:0]
      } 
      else write("Middle of transliterate: Something is wrong!")
    }
  } 
if (*transedLine = 0) then transedLine ||:= lineIn
return transedLine
end
